<!DOCTYPE html>
<html>

<head>
    <script>
        /*  magic values:

            square type:
            T, E, F, X, Y, Z, P
            tile, edge, finis, lying horizontally, standing, lying vertically, path

            way:
            u, d, l, r, *, .
            up, down, left, right, possible, undecided
        */
        console.clear();

        function makeState(rows) {
            let state = [];

            rows.forEach((row, i) => {
                state.push([]);

                [...row].forEach((c, j) => {
                    state[i].push({
                        type: c
                    });

                    if (c == 'T' || c == 'X' || c == 'Y' || c == 'Z') {
                        /*state[i][j].wayX = undefined;
                        state[i][j].wayY = undefined;
                        state[i][j].wayZ = undefined;*/
                    }
                })
            })

            return state;
        }

        let state = makeState([
            "TTTEEEEEEE",
            "TYTTEEEEEE",
            "TTTTEETTTE",
            "ETTTTTTTTT",
            "EEEEEETFTT",
            "EEEEEETTTE"
        ]);

        function getPossiblePlaces(start) {
            switch (start.square.type) {
                case 'X': {
                    return [
                        { square: { type: 'Y', wayY: { pos: start.pos, type: 'X' } }, pos: { x: start.pos.x + 2, y: start.pos.y, } },
                        { square: { type: 'Y', wayY: { pos: start.pos, type: 'X' } }, pos: { x: start.pos.x - 1, y: start.pos.y, } },
                        { square: { type: 'X', wayX: { pos: start.pos, type: 'X' } }, pos: { x: start.pos.x, y: start.pos.y + 1, } },
                        { square: { type: 'X', wayX: { pos: start.pos, type: 'X' } }, pos: { x: start.pos.x, y: start.pos.y - 1, } }
                    ];
                }
                case 'Y': {
                    return [
                        { square: { type: 'X', wayX: { pos: start.pos, type: 'Y' } }, pos: { x: start.pos.x + 1, y: start.pos.y, } },
                        { square: { type: 'X', wayX: { pos: start.pos, type: 'Y' } }, pos: { x: start.pos.x - 2, y: start.pos.y, } },
                        { square: { type: 'Z', wayZ: { pos: start.pos, type: 'Y' } }, pos: { x: start.pos.x, y: start.pos.y + 1, } },
                        { square: { type: 'Z', wayZ: { pos: start.pos, type: 'Y' } }, pos: { x: start.pos.x, y: start.pos.y - 2, } }
                    ];
                }
                case 'Z': {
                    return [
                        { square: { type: 'Z', wayZ: { pos: start.pos, type: 'Z' } }, pos: { x: start.pos.x + 1, y: start.pos.y, } },
                        { square: { type: 'Z', wayZ: { pos: start.pos, type: 'Z' } }, pos: { x: start.pos.x - 1, y: start.pos.y, } },
                        { square: { type: 'Y', wayY: { pos: start.pos, type: 'Z' } }, pos: { x: start.pos.x, y: start.pos.y + 2, } },
                        { square: { type: 'Y', wayY: { pos: start.pos, type: 'Z' } }, pos: { x: start.pos.x, y: start.pos.y - 1, } }
                    ];
                }
            }
        }

        function isValidPlace(place) {
            if (place.pos.y >= 0 && place.pos.y < state.length && place.pos.x >= 0 && place.pos.x < state[place.pos.y].length) {
                if (state[place.pos.y][place.pos.x].type == 'E') {
                    return false;
                }
                else {
                    let squareType, x, y;

                    if (place.square) squareType = place.square.type;
                    else squareType = state[place.pos.y][place.pos.x].type === 'E' ? 'E' : 'T';

                    if (squareType == 'X') {
                        x = place.pos.x + 1;
                        y = place.pos.y;
                    }
                    else if (squareType == 'Z') {
                        x = place.pos.x;
                        y = place.pos.y + 1;
                    }
                    else {
                        return true;
                    }

                    return isValidPlace({ pos: { x, y } });
                }
            }
            else {
                // out of bounds
                return false;
            }
        }

        function trySetWay(stateSquare, placeSquare) {
            if (!stateSquare.wayX && placeSquare.wayX) {
                stateSquare.wayX = placeSquare.wayX;
                return true;
            }
            else if (!stateSquare.wayY && placeSquare.wayY) {
                stateSquare.wayY = placeSquare.wayY;
                return true;
            }
            else if (!stateSquare.wayZ && placeSquare.wayZ) {
                stateSquare.wayZ = placeSquare.wayZ;
                return true;
            }
            else {
                return false;
            }
        }

        function explore() {

            // leia algus ja lÃµpp :)

            let startPlace, finisPlace;

            state.forEach((row, i) => {
                row.forEach((square, j) => {
                    if (square.type === 'X' || square.type === 'Y' || square.type === 'Z') {
                        startPlace = {
                            square,
                            pos: {
                                x: j,
                                y: i
                            }
                        }
                    }
                    else if (square.type === 'F') {
                        finisPlace = {
                            square,
                            pos: {
                                x: j,
                                y: i
                            }
                        }
                    }
                });
            });

            let safeGuard = 1000;

            let unknownPlaces = [startPlace];
            while (unknownPlaces.length > 0) {
                let currentPlace = unknownPlaces.shift();

                //console.log("1.", currentPlace)

                let possiblePlaces = getPossiblePlaces(currentPlace);

                possiblePlaces.forEach(place => {
                    if (isValidPlace(place)) {
                        if (state[place.pos.y][place.pos.x].type === 'E') console.log("a");

                        //console.log(place, state[place.pos.y][place.pos.x]);

                        let sSquare = state[place.pos.y][place.pos.x];
                        let pSquare = place.square;

                        if (trySetWay(sSquare, pSquare)) {
                            unknownPlaces.push(place);
                        }
                    }
                });

                safeGuard--;
                if (safeGuard <= 0) break;
            }

            safeGuard = 100;

            let way = finisPlace.square.wayY;

            if (way) {
                while (way.pos.x !== startPlace.pos.x || way.pos.y !== startPlace.pos.y || way.type !== startPlace.square.type) {
                    state[way.pos.y][way.pos.x].type = 'P';
                    //state[way.pos.y][way.pos.x].type = way.type;

                    way = state[way.pos.y][way.pos.x]["way" + way.type];

                    safeGuard--;
                    if (safeGuard <= 0) break;
                }

                finisPlace.square.type = 'W';
            }
        }

        function render() {
            let view = "<table>";

            let color = { index: -1, type: '' };

            state.forEach((row, i) => {
                view += "<tr>";
                row.forEach((square, j) => {
                    view += '<td class="';

                    if (color.index === i * row.length + j) {
                        view += color.type;
                        console.log("jee");
                    }
                    else {
                        view += square.type;
                    }

                    view += '"></td>'

                    if (square.type == 'X') {
                        color.index = i * row.length + j + 1;
                        color.type = square.type;
                    }
                    else if (square.type == 'Z') {
                        color.index = (i + 1) * row.length + j;
                        color.type = square.type;
                    }
                })
                view += "</tr>";
            });

            view += "</table>";

            laud.innerHTML = view;
        }

        function algus() {
            explore();
            render();
        }
    </script>
    <style>
        td {
            height: 50px;
            width: 50px;
        }

        .E {
            background-color: burlywood;
        }

        .T {
            background-color: antiquewhite;
        }

        .F {
            background-color: black;
        }

        .W {
            background-color: gold;
        }

        .X {
            background-color: pink;
        }

        .Y {
            background-color: lightblue;
        }

        .Z {
            background-color: palegreen;
        }

        .P {
            background-color: silver;
        }
    </style>
</head>

<body onload="algus()">
    <pre id="laud"></pre>
    <div id="vastus"></div>
</body>

</html>
